#!/usr/bin/env python3
"""
Vulnerability Alert Handler
‰ºÅÊ•≠Á¥öÊºèÊ¥ûÂëäË≠¶ËôïÁêÜËàáËá™ÂãïÂåñ‰øÆÂæ©Â∑•ÂÖ∑
"""

import requests
import json
import argparse
import sys
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from typing import List, Dict, Optional


@dataclass
class VulnerabilityAlert:
    """ÊºèÊ¥ûÂëäË≠¶Ë≥áÊñôÁµêÊßã"""
    id: str
    severity: str
    package_name: str
    affected_version: str
    fixed_version: Optional[str]
    cve_id: Optional[str]
    repository: str
    created_at: str
    manifest_path: str
    
    def age_days(self) -> int:
        """Ë®àÁÆóÂëäË≠¶Â≠òÂú®Â§©Êï∏"""
        created = datetime.fromisoformat(self.created_at.replace('Z', '+00:00'))
        return (datetime.now(created.tzinfo) - created).days


class VulnerabilityManager:
    """ÊºèÊ¥ûÁÆ°ÁêÜÂô®"""
    
    SEVERITY_ORDER = {
        'critical': 4,
        'high': 3,
        'moderate': 2,
        'medium': 2,
        'low': 1
    }
    
    def __init__(self, token: str, org: str):
        self.token = token
        self.org = org
        self.headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28'
        }
        
    def get_vulnerability_alerts(self, repo: Optional[str] = None, 
                                state: str = 'open') -> List[VulnerabilityAlert]:
        """ÂèñÂæóÊºèÊ¥ûÂëäË≠¶Ê∏ÖÂñÆ"""
        if repo:
            url = f'https://api.github.com/repos/{self.org}/{repo}/dependabot/alerts'
        else:
            url = f'https://api.github.com/orgs/{self.org}/dependabot/alerts'
            
        alerts = []
        page = 1
        
        print(f"Fetching vulnerability alerts from {url}...")
        
        while True:
            try:
                response = requests.get(
                    f"{url}?state={state}&per_page=100&page={page}",
                    headers=self.headers,
                    timeout=30
                )
                
                if response.status_code == 404:
                    print(f"Warning: Repository or organization not found or Dependabot not enabled")
                    break
                elif response.status_code != 200:
                    print(f"Error fetching alerts: {response.status_code}")
                    print(f"Response: {response.text}")
                    break
                    
                data = response.json()
                if not data:
                    break
                    
                for alert_data in data:
                    # Extract fixed version from vulnerabilities
                    fixed_version = None
                    vulnerabilities = alert_data.get('security_advisory', {}).get('vulnerabilities', [])
                    if vulnerabilities:
                        fixed_version = vulnerabilities[0].get('patched_versions', 'N/A')
                    
                    alert = VulnerabilityAlert(
                        id=str(alert_data['number']),
                        severity=alert_data['security_advisory']['severity'].lower(),
                        package_name=alert_data['dependency']['package']['name'],
                        affected_version=alert_data['dependency'].get('manifest_path', 'N/A'),
                        fixed_version=fixed_version,
                        cve_id=alert_data['security_advisory'].get('cve_id'),
                        repository=alert_data.get('repository', {}).get('full_name', f"{self.org}/{repo}"),
                        created_at=alert_data['created_at'],
                        manifest_path=alert_data['dependency'].get('manifest_path', 'N/A')
                    )
                    alerts.append(alert)
                    
                page += 1
                
            except requests.exceptions.RequestException as e:
                print(f"Request error: {e}")
                break
            
        return alerts
    
    def categorize_alerts(self, alerts: List[VulnerabilityAlert]) -> Dict[str, List[VulnerabilityAlert]]:
        """ÂàÜÈ°ûÂëäË≠¶"""
        categories = {
            'critical_immediate': [],     # ÈúÄË¶ÅÁ´ãÂç≥ËôïÁêÜ
            'high_urgent': [],           # Á∑äÊÄ•ËôïÁêÜÔºà24Â∞èÊôÇÂÖßÔºâ
            'moderate_scheduled': [],    # ÊéíÁ®ãËôïÁêÜÔºà1ÈÄ±ÂÖßÔºâ
            'low_routine': []           # ‰æãË°åËôïÁêÜÔºà1ÂÄãÊúàÂÖßÔºâ
        }
        
        for alert in alerts:
            age_days = alert.age_days()
            
            if alert.severity == 'critical':
                categories['critical_immediate'].append(alert)
            elif alert.severity == 'high' or (alert.severity == 'moderate' and age_days > 7):
                categories['high_urgent'].append(alert)
            elif alert.severity in ['moderate', 'medium'] or age_days > 30:
                categories['moderate_scheduled'].append(alert)
            else:
                categories['low_routine'].append(alert)
                
        return categories
    
    def create_remediation_plan(self, categorized_alerts: Dict[str, List[VulnerabilityAlert]]) -> Dict[str, Dict]:
        """Âª∫Á´ã‰øÆÂæ©Ë®àÁï´"""
        plan = {}
        
        strategies = {
            'critical_immediate': {
                'timeline': 'Á´ãÂç≥ËôïÁêÜ',
                'strategy': 'hotfix',
                'approval_required': False,
                'auto_merge': True,
                'notification_channels': ['slack-security', 'email-cto'],
                'sla_hours': 4
            },
            'high_urgent': {
                'timeline': '24Â∞èÊôÇÂÖß',
                'strategy': 'priority_patch',
                'approval_required': True,
                'auto_merge': False,
                'notification_channels': ['slack-dev-team'],
                'sla_hours': 24
            },
            'moderate_scheduled': {
                'timeline': '1ÈÄ±ÂÖß',
                'strategy': 'scheduled_update',
                'approval_required': True,
                'auto_merge': False,
                'notification_channels': ['email-team-leads'],
                'sla_hours': 168
            },
            'low_routine': {
                'timeline': '1ÂÄãÊúàÂÖß',
                'strategy': 'routine_maintenance',
                'approval_required': False,
                'auto_merge': True,
                'notification_channels': ['email-maintainers'],
                'sla_hours': 720
            }
        }
        
        for category, alerts in categorized_alerts.items():
            if not alerts:
                continue
                
            plan[category] = strategies[category].copy()
            plan[category]['alerts'] = [asdict(a) for a in alerts]
            plan[category]['count'] = len(alerts)
            
        return plan

    def generate_security_advisory(self, alerts: List[VulnerabilityAlert]) -> str:
        """Áî¢ÁîüÂÆâÂÖ®Âª∫Ë≠∞Â†±Âëä"""
        report = f"""# ÊºèÊ¥ûÂÆâÂÖ®Âª∫Ë≠∞Â†±Âëä

ÁîüÊàêÊôÇÈñì: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
ÁµÑÁπî: {self.org}

## ÊëòË¶ÅÁµ±Ë®à

Á∏ΩÊºèÊ¥ûÊï∏Èáè: **{len(alerts)}**
"""
        
        if not alerts:
            report += "\n‚úÖ Ê≤íÊúâÁôºÁèæÈñãÊîæÁöÑÊºèÊ¥ûÂëäË≠¶„ÄÇ\n"
            return report
        
        # ‰æùÂö¥ÈáçÂ∫¶Áµ±Ë®à
        severity_counts = {}
        for alert in alerts:
            severity_counts[alert.severity] = severity_counts.get(alert.severity, 0) + 1
            
        report += "\n### ‰æùÂö¥ÈáçÂ∫¶ÂàÜÂ∏É\n\n"
        severity_order = ['critical', 'high', 'moderate', 'medium', 'low']
        for severity in severity_order:
            count = severity_counts.get(severity, 0)
            if count > 0:
                emoji = {'critical': 'üî¥', 'high': 'üü†', 'moderate': 'üü°', 'medium': 'üü°', 'low': 'üü¢'}
                report += f"{emoji.get(severity, '‚ö™')} **{severity.upper()}**: {count}\n"
            
        # ÂèóÂΩ±ÈüøÁöÑÂ•ó‰ª∂Áµ±Ë®à
        package_counts = {}
        for alert in alerts:
            package_counts[alert.package_name] = package_counts.get(alert.package_name, 0) + 1
            
        report += "\n### ÂèóÂΩ±ÈüøÂ•ó‰ª∂ TOP 10\n\n"
        sorted_packages = sorted(package_counts.items(), key=lambda x: x[1], reverse=True)[:10]
        for i, (package, count) in enumerate(sorted_packages, 1):
            report += f"{i}. **{package}**: {count} ÂÄãÊºèÊ¥û\n"
            
        # CVE Áµ±Ë®à
        cve_alerts = [a for a in alerts if a.cve_id]
        if cve_alerts:
            report += f"\n### CVE Á∑®Ëôü\n\nÂ∑≤Ë≠òÂà• {len(cve_alerts)} ÂÄã CVE ÊºèÊ¥û\n\n"
            for alert in cve_alerts[:10]:
                report += f"- [{alert.cve_id}](https://cve.mitre.org/cgi-bin/cvename.cgi?name={alert.cve_id}) - {alert.package_name}\n"
        
        # ‰øÆÂæ©Âª∫Ë≠∞
        report += "\n## ‰øÆÂæ©Âª∫Ë≠∞\n\n"
        
        critical_alerts = [a for a in alerts if a.severity == 'critical']
        if critical_alerts:
            report += "### üö® Á´ãÂç≥Ë°åÂãïÈ†ÖÁõÆÔºàCriticalÔºâ\n\n"
            for alert in critical_alerts[:5]:
                report += f"#### {alert.package_name}\n"
                report += f"- **Repository**: {alert.repository}\n"
                report += f"- **Manifest**: `{alert.manifest_path}`\n"
                if alert.cve_id:
                    report += f"- **CVE**: {alert.cve_id}\n"
                if alert.fixed_version:
                    report += f"- **‰øÆÂæ©ÁâàÊú¨**: {alert.fixed_version}\n"
                report += f"- **ÂëäË≠¶ ID**: #{alert.id}\n"
                report += "\n"
        
        high_alerts = [a for a in alerts if a.severity == 'high']
        if high_alerts:
            report += f"### ‚ö†Ô∏è  È´òÂÑ™ÂÖàÁ¥öÈ†ÖÁõÆÔºàHighÔºâ\n\n"
            report += f"ÁôºÁèæ {len(high_alerts)} ÂÄãÈ´òÂö¥ÈáçÂ∫¶ÊºèÊ¥ûÔºåÂª∫Ë≠∞Âú® 24 Â∞èÊôÇÂÖßËôïÁêÜ„ÄÇ\n\n"
        
        # SLA Âª∫Ë≠∞
        report += "\n## SLA Âª∫Ë≠∞\n\n"
        report += "| Âö¥ÈáçÂ∫¶ | ËôïÁêÜÊôÇÈôê | Á≠ñÁï• |\n"
        report += "|--------|---------|------|\n"
        report += "| Critical | 4 Â∞èÊôÇ | Á´ãÂç≥ Hotfix |\n"
        report += "| High | 24 Â∞èÊôÇ | ÂÑ™ÂÖà‰øÆË£ú |\n"
        report += "| Moderate | 1 ÈÄ± | ÊéíÁ®ãÊõ¥Êñ∞ |\n"
        report += "| Low | 1 ÂÄãÊúà | ‰æãË°åÁ∂≠Ë≠∑ |\n"
        
        return report

    def filter_by_severity(self, alerts: List[VulnerabilityAlert], 
                          min_severity: str) -> List[VulnerabilityAlert]:
        """Ê†πÊìöÂö¥ÈáçÂ∫¶ÈÅéÊøæÂëäË≠¶"""
        threshold = self.SEVERITY_ORDER.get(min_severity.lower(), 0)
        return [a for a in alerts if self.SEVERITY_ORDER.get(a.severity, 0) >= threshold]


def main():
    parser = argparse.ArgumentParser(
        description='Vulnerability Alert Handler - ‰ºÅÊ•≠Á¥öÊºèÊ¥ûÁÆ°ÁêÜÂ∑•ÂÖ∑'
    )
    parser.add_argument('--token', help='GitHub Token')
    parser.add_argument('--org', required=True, help='Organization name')
    parser.add_argument('--repo', help='Repository name (optional)')
    parser.add_argument('--severity-threshold', 
                       choices=['low', 'moderate', 'medium', 'high', 'critical'],
                       default='low',
                       help='Minimum severity to report')
    parser.add_argument('--output-format', 
                       choices=['markdown', 'json'],
                       default='markdown',
                       help='Output format')
    parser.add_argument('--output-file', help='Output file path')
    
    args = parser.parse_args()
    
    # Get token from args or environment
    import os
    token = args.token or os.getenv('GITHUB_TOKEN')
    if not token:
        print("Error: GitHub token required. Use --token or set GITHUB_TOKEN")
        sys.exit(1)
    
    vm = VulnerabilityManager(token, args.org)
    
    # Fetch alerts
    print(f"Fetching vulnerability alerts for {args.org}...")
    alerts = vm.get_vulnerability_alerts(args.repo)
    print(f"Found {len(alerts)} total alerts")
    
    # Filter by severity
    filtered_alerts = vm.filter_by_severity(alerts, args.severity_threshold)
    print(f"After filtering by {args.severity_threshold}: {len(filtered_alerts)} alerts")
    
    # Generate output
    if args.output_format == 'json':
        # Categorize and create plan
        categorized = vm.categorize_alerts(filtered_alerts)
        plan = vm.create_remediation_plan(categorized)
        output = json.dumps(plan, indent=2, ensure_ascii=False)
    else:
        output = vm.generate_security_advisory(filtered_alerts)
    
    # Save or print
    if args.output_file:
        with open(args.output_file, 'w', encoding='utf-8') as f:
            f.write(output)
        print(f"Report saved to {args.output_file}")
    else:
        print("\n" + "="*70)
        print(output)
        print("="*70)


if __name__ == "__main__":
    main()
