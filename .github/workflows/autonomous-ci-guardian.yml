name: "ğŸ¤– Autonomous CI Guardian"

on:
  push:
    branches: [main, develop, staging]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '*/5 * * * *'

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  SAFETY_THRESHOLD: "0.99"
  PERFORMANCE_THRESHOLD: "1000ms"
  MEMORY_THRESHOLD: "512MB"
  CRITICAL_SERVICES: "flight-control,gps-nav,obstacle-detect"
  PRIMARY_SERVICE_HEALTH_URL: "http://localhost:8001/health"
  CANARY_SERVICE_URL: "http://localhost:8080"
  HEALTH_CHECK_DELAY: "5"
  CANARY_MONITOR_DURATION: "300"
  ERROR_RATE_THRESHOLD: "0.01"
  STAGED_DEPLOY_PERCENTAGES: "25,50,100"
  STAGED_DEPLOY_INTERVAL: "120"
  SERVICE_STARTUP_DELAY: "3"
  METRICS_ENDPOINT_TIMEOUT: "50"
  DRY_RUN: "true"

jobs:
  predictive-failure-detection:
    runs-on: ubuntu-latest
    outputs:
      risk_level: ${{ steps.risk-assessment.outputs.level }}
      should_proceed: ${{ steps.risk-assessment.outputs.proceed }}
      predicted_failures: ${{ steps.ml-predict.outputs.failures }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 50

      - name: ğŸ§  ML failure prediction
        id: ml-predict
        run: |

          cat prediction.json

          PREDICTIONS=$(cat prediction.json | jq -c '.')
          echo "failures=$PREDICTIONS" >> "$GITHUB_OUTPUT"

      - name: ğŸ“ˆ Complexity and change analysis
        id: complexity-analysis
        run: |
          cat > analyze_complexity.sh << 'BASH'
          #!/bin/bash
          set -euo pipefail

          FILES=$(find . -name "*.js" -o -name "*.ts")
          if [ -n "$FILES" ]; then
            COMPLEXITY=$(echo "$FILES" | xargs wc -l | tail -1 | awk '{print $1}')
          else
            COMPLEXITY=0
          fi

          CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null | wc -l)
          CHANGED_LINES=$(git diff HEAD~1 2>/dev/null | grep '^[+-]' | wc -l)

          if [ "$COMPLEXITY" -gt 5000 ]; then
            RISK="HIGH"
          elif [ "$COMPLEXITY" -gt 2000 ]; then
            RISK="MEDIUM"
          else
            RISK="LOW"
          fi

          echo "complexity=$COMPLEXITY" >> "$GITHUB_OUTPUT"
          echo "changed_files=$CHANGED_FILES" >> "$GITHUB_OUTPUT"
          echo "changed_lines=$CHANGED_LINES" >> "$GITHUB_OUTPUT"
          echo "complexity_risk=$RISK" >> "$GITHUB_OUTPUT"
          BASH

          bash analyze_complexity.sh

      - name: ğŸ” Dependency vulnerability scan
        id: security-scan
        run: |
          if [ -f "package.json" ]; then
            npm audit --json > audit.json 2>&1 || true

            VULNERABILITIES=$(cat audit.json | jq '.metadata.vulnerabilities.total' 2>/dev/null || echo "0")
            CRITICAL=$(cat audit.json | jq '.metadata.vulnerabilities.critical' 2>/dev/null || echo "0")
          else
            echo "é Node.js å°ˆæ¡ˆï¼Œè·³é npm audit"
            VULNERABILITIES=0
            CRITICAL=0
          fi

          echo "total_vulnerabilities=$VULNERABILITIES" >> "$GITHUB_OUTPUT"
          echo "critical_vulnerabilities=$CRITICAL" >> "$GITHUB_OUTPUT"

          if [ "$CRITICAL" -gt 0 ]; then
            echo "security_status=CRITICAL" >> "$GITHUB_OUTPUT"
          elif [ "$VULNERABILITIES" -gt 5 ]; then
            echo "security_status=WARNING" >> "$GITHUB_OUTPUT"
          else
            echo "security_status=SAFE" >> "$GITHUB_OUTPUT"
          fi

      - name: âš–ï¸ Comprehensive risk assessment
        id: risk-assessment
        env:
          PREDICTED_FAILURES: ${{ steps.ml-predict.outputs.failures }}
          CRITICAL_VULNS: ${{ steps.security-scan.outputs.critical_vulnerabilities }}
        run: |
          # è‡ªå‹•åŒ–é¢¨éšªè©•ä¼°é‚è¼¯ï¼ˆç„¡éœ€å¤–éƒ¨ Python æª”æ¡ˆï¼‰
          FAILURES=$(echo "$PREDICTED_FAILURES" | jq -r '.high_risk_areas | length' 2>/dev/null || echo "0")
          CRITICAL="${CRITICAL_VULNS:-0}"

          # å®Œå…¨è‡ªä¸»æ±ºç­–ï¼šæ‰€æœ‰é¢¨éšªç­‰ç´šéƒ½è‡ªå‹•è™•ç†
          # PROCEED æ§åˆ¶æ˜¯å¦åŸ·è¡Œå¥åº·æª¢æŸ¥ - CRITICAL é¢¨éšªè·³éå¥åº·æª¢æŸ¥ç›´æ¥é€²å…¥ä¿®å¾©æµç¨‹
          if [ "$CRITICAL" -gt 0 ]; then
            LEVEL="CRITICAL"
            PROCEED="false"  # è·³éå¥åº·æª¢æŸ¥ï¼ˆproceed=falseï¼‰ï¼Œauto-remediation ä»æœƒåŸ·è¡Œä¸¦è§¸ç™¼å›æ»¾
            echo "ğŸš¨ åµæ¸¬åˆ° CRITICAL ç´šåˆ¥å®‰å…¨æ¼æ´ï¼Œå°‡è·³éå¥åº·æª¢æŸ¥ä¸¦è§¸ç™¼è‡ªå‹•å›æ»¾"
          elif [ "$FAILURES" -gt 2 ]; then
            LEVEL="HIGH"
            PROCEED="true"  # è‡ªå‹•é‡‘çµ²é›€éƒ¨ç½²
          elif [ "$FAILURES" -gt 0 ]; then
            LEVEL="MEDIUM"
            PROCEED="true"  # è‡ªå‹•åˆ†éšæ®µéƒ¨ç½²
          else
            LEVEL="LOW"
            PROCEED="true"  # è‡ªå‹•å®Œæ•´éƒ¨ç½²
          fi

          echo "{\"level\": \"$LEVEL\", \"proceed\": \"$PROCEED\", \"auto_decision\": true}" > assessment.json
          cat assessment.json

          echo "level=$LEVEL" >> "$GITHUB_OUTPUT"
          echo "proceed=$PROCEED" >> "$GITHUB_OUTPUT"

  critical-service-health-check:
    needs: predictive-failure-detection
    runs-on: ubuntu-latest
    if: ${{ needs.predictive-failure-detection.outputs.proceed == 'true' }}

    strategy:
      matrix:
        service: [flight-control, gps-nav, obstacle-detect, telemetry]
      fail-fast: true

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ¥ Check ${{ matrix.service }} health
        id: health-check
        timeout-minutes: 5
        run: |
          cat > health_check.sh << 'BASH'
          #!/bin/bash
          set -euo pipefail

          SERVICE=$1
          echo "æª¢æŸ¥ $SERVICE å¥åº·ç‹€æ…‹..."

          # é›†ä¸­å®šç¾©æœå‹™ç«¯å£æ˜ å°„
          declare -A SERVICE_PORTS=(
            ["flight-control"]=8001
            ["gps-nav"]=8002
            ["obstacle-detect"]=8003
            ["telemetry"]=8004
          )

          docker-compose up -d "$SERVICE" 2>&1 | tee startup.log
          STARTUP_EXIT=${PIPESTATUS[0]}

          sleep ${{ env.SERVICE_STARTUP_DELAY }}

          PORT=${SERVICE_PORTS[$SERVICE]}
          curl -f http://localhost:${PORT}/health || exit 1

          HEALTH_EXIT=$?

          RESPONSE_TIME=$(curl -w '%{time_total}' -o /dev/null -s http://localhost:${PORT}/health)
          if awk -v rt="$RESPONSE_TIME" 'BEGIN {exit !(rt > 1.0)}'; then
            echo "âš ï¸  æ€§èƒ½è­¦å‘Šï¼š$SERVICE éŸ¿æ‡‰æ™‚é–“ ${RESPONSE_TIME}sï¼ˆé–¾å€¼ï¼š1.0sï¼‰"
            exit 1
          fi

          # å–å¾—å®¹å™¨ ID ä»¥ç¢ºä¿æ­£ç¢ºæŸ¥è©¢çµ±è¨ˆè³‡è¨Š
          CONTAINER_ID=$(docker-compose ps -q "$SERVICE")
          if [ -n "$CONTAINER_ID" ]; then
            MEMORY=$(docker stats --no-stream "$CONTAINER_ID" | tail -1 | awk '{print $7}')
            echo "å…§å­˜ä½¿ç”¨ï¼š$MEMORY"
          else
            echo "âš ï¸  ç„¡æ³•æ‰¾åˆ°æœå‹™ $SERVICE çš„å®¹å™¨ï¼Œç„¡æ³•æŸ¥è©¢å…§å­˜ä½¿ç”¨"
          fi

          docker-compose down

          exit $((STARTUP_EXIT + HEALTH_EXIT))
          BASH

          bash health_check.sh ${{ matrix.service }}

      - name: ğŸ“Š Record service metrics
        if: always()
        run: |
          {
            "service": "${{ matrix.service }}",
            "timestamp": "TIMESTAMP_PLACEHOLDER",
            "status": "${{ steps.health-check.outcome }}"
          }
          JSON
          
          # æ›¿æ›ä½”ä½ç¬¦ä»¥é¿å… shell è®Šæ•¸å±•é–‹å•é¡Œ
          sed -i "s/TIMESTAMP_PLACEHOLDER/$TIMESTAMP/" metrics.json
          cat metrics.json

  auto-remediation:
    needs: [predictive-failure-detection, critical-service-health-check]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Remediation decision
        id: remediation-decision
        run: |
          RISK_LEVEL="${{ needs.predictive-failure-detection.outputs.risk_level }}"

          case "$RISK_LEVEL" in
            CRITICAL)
              echo "action=ROLLBACK" >> "$GITHUB_OUTPUT"
              echo "reason=Critical risk detected" >> "$GITHUB_OUTPUT"
              ;;
            HIGH)
              echo "action=CANARY_DEPLOY" >> "$GITHUB_OUTPUT"
              echo "reason=High risk - deploying to 5% traffic" >> "$GITHUB_OUTPUT"
              ;;
            MEDIUM)
              echo "action=STAGED_DEPLOY" >> "$GITHUB_OUTPUT"
              echo "reason=Medium risk - staged deployment" >> "$GITHUB_OUTPUT"
              ;;
            LOW)
              echo "action=FULL_DEPLOY" >> "$GITHUB_OUTPUT"
              echo "reason=Low risk - full deployment" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "action=ROLLBACK" >> "$GITHUB_OUTPUT"
              echo "reason=Unknown risk level" >> "$GITHUB_OUTPUT"
              ;;
          esac

      - name: â®ï¸ Automatic rollback when critical
        if: ${{ steps.remediation-decision.outputs.action == 'ROLLBACK' }}
        run: |
          echo "ğŸš¨ è§¸ç™¼è‡ªå‹•å›æ»¾..."
          PREVIOUS_VERSION=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          echo "å›æ»¾åˆ°ç‰ˆæœ¬ï¼š$PREVIOUS_VERSION"

          # é©—è­‰ tag æ˜¯å¦å­˜åœ¨ä¸”æ ¼å¼æ­£ç¢ºï¼ˆå¦‚ v1.2.3ï¼‰
          if [ -z "$PREVIOUS_VERSION" ]; then
            echo "âŒ ç„¡æ³•æ‰¾åˆ°å‰ä¸€å€‹ç‰ˆæœ¬ï¼Œå›æ»¾å¤±æ•—"
            exit 1
          fi
          if ! [[ "$PREVIOUS_VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ ç‰ˆæœ¬æ ¼å¼ä¸æ­£ç¢º: $PREVIOUS_VERSION"
            exit 1
          fi
          
          # é©—è­‰ tag æ˜¯å¦ç¶“é GPG ç°½åï¼ˆå¯é¸ï¼Œå¢å¼·å®‰å…¨æ€§ï¼‰
          if git tag -v "$PREVIOUS_VERSION" 2>/dev/null; then
            echo "âœ… ç‰ˆæœ¬ $PREVIOUS_VERSION å·²é€šé GPG ç°½åé©—è­‰"
          else
            echo "âš ï¸  è­¦å‘Šï¼šç‰ˆæœ¬ $PREVIOUS_VERSION æœªç¶“é GPG ç°½åé©—è­‰ï¼Œä½†ç¹¼çºŒåŸ·è¡Œï¼ˆæ¼”ç¤ºæ¨¡å¼ï¼‰"
          fi
          
          git checkout "$PREVIOUS_VERSION"
          docker-compose build --no-cache
          docker-compose up -d

          sleep ${{ env.HEALTH_CHECK_DELAY }}
          curl -f ${{ env.PRIMARY_SERVICE_HEALTH_URL }} || echo "âš ï¸  å¥åº·æª¢æŸ¥å¤±æ•—ï¼ˆæ¼”ç¤ºæ¨¡å¼ï¼‰"
          echo "âœ… å›æ»¾å®Œæˆ"

      - name: ğŸ¦ Canary deployment
        if: ${{ steps.remediation-decision.outputs.action == 'CANARY_DEPLOY' }}
        run: |
          echo "ğŸ¦ å•Ÿå‹•é‡‘çµ²é›€éƒ¨ç½²..."
          cat > canary-deploy.yaml << 'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: autonomous-system-canary
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: autonomous-system
                version: canary
            template:
              metadata:
                labels:
                  app: autonomous-system
                  version: canary
              spec:
                containers:
                - name: app
                  image: autonomous-system:latest
                  resources:
                    limits:
                      cpu: "500m"
                      memory: "512Mi"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: autonomous-system-canary
          spec:
            selector:
              app: autonomous-system
              version: canary
            ports:
            - port: 8080
              targetPort: 8080
          YAML

          echo "éƒ¨ç½²åˆ° 5% æµé‡"
          if [ "${{ env.DRY_RUN }}" != "true" ]; then
            kubectl apply -f canary-deploy.yaml
            
            # å•Ÿå‹• port-forward ä»¥ä¾¿ç›£æ§ï¼ˆç¢ºä¿æ¸…ç†ï¼‰
            kubectl port-forward svc/autonomous-system-canary 8080:8080 > /tmp/portforward.log 2>&1 &
            PF_PID=$!
            
            # è¨­å®š trap ä»¥ç¢ºä¿åœ¨ä»»ä½•æƒ…æ³ä¸‹éƒ½æ¸…ç† port-forward
            trap "kill $PF_PID 2>/dev/null || true" EXIT
            
            # ç­‰å¾… port-forward å°±ç·’ï¼ˆæ¯ 5 ç§’æª¢æŸ¥ä¸€æ¬¡ï¼Œç¸½è¶…æ™‚ç”± METRICS_ENDPOINT_TIMEOUT æ§åˆ¶ï¼‰
            TIMEOUT=${{ env.METRICS_ENDPOINT_TIMEOUT }}
            INTERVAL=5
            MAX_ATTEMPTS=$((TIMEOUT / INTERVAL))
            for i in $(seq 1 $MAX_ATTEMPTS); do
              if curl -s ${{ env.CANARY_SERVICE_URL }}/metrics > /dev/null 2>&1; then
                break
              fi
              echo "ç­‰å¾… metrics ç«¯é»å°±ç·’ ($i/$MAX_ATTEMPTS)..."
              sleep $INTERVAL
            done

            # é©—è­‰ metrics ç«¯é»æœ€çµ‚æ˜¯å¦å°±ç·’
            if ! curl -s ${{ env.CANARY_SERVICE_URL }}/metrics > /dev/null 2>&1; then
              kill $PF_PID 2>/dev/null || true
              echo "âŒ metrics ç«¯é»åœ¨ ${{ env.METRICS_ENDPOINT_TIMEOUT }} ç§’å¾Œä»æœªå°±ç·’ï¼Œé‡‘çµ²é›€éƒ¨ç½²å¤±æ•—"
              exit 1
            fi

            echo "ç›£æ§é‡‘çµ²é›€éƒ¨ç½² ${{ env.CANARY_MONITOR_DURATION }} ç§’..."
            sleep ${{ env.CANARY_MONITOR_DURATION }}

            # é è¨­ç‚º 0.0 ä»¥è™•ç†æŒ‡æ¨™ä¸å¯ç”¨çš„æƒ…æ³
            ERROR_RATE=$(curl -s ${{ env.CANARY_SERVICE_URL }}/metrics 2>/dev/null | grep error_rate | awk '{print $NF}')
            if [ -z "$ERROR_RATE" ]; then
              echo "âš ï¸  ç„¡æ³•å–å¾—éŒ¯èª¤ç‡æŒ‡æ¨™ï¼Œå‡è¨­ç‚º 0.0ï¼ˆå¥åº·ç‹€æ…‹ï¼‰"
              ERROR_RATE="0.0"
            fi
            
            if awk -v er="$ERROR_RATE" -v threshold="${{ env.ERROR_RATE_THRESHOLD }}" 'BEGIN {exit !(er > threshold)}'; then
              kill $PF_PID 2>/dev/null || true
              echo "âŒ é‡‘çµ²é›€éƒ¨ç½²å¤±æ•—ï¼ŒéŒ¯èª¤ç‡ $ERROR_RATEï¼ˆé–¾å€¼ï¼š${{ env.ERROR_RATE_THRESHOLD }}ï¼‰"
              exit 1
            fi
            
            echo "âœ… é‡‘çµ²é›€éƒ¨ç½²æˆåŠŸï¼ŒéŒ¯èª¤ç‡ $ERROR_RATE"
          else
            echo "[DRY-RUN] æ¨¡æ“¬é‡‘çµ²é›€éƒ¨ç½²ï¼Œä¸å¯¦éš›åŸ·è¡Œ"
            echo "[DRY-RUN] è·³éç›£æ§èˆ‡æŒ‡æ¨™æª¢æŸ¥"
            echo "âœ… [DRY-RUN] é‡‘çµ²é›€éƒ¨ç½²æµç¨‹æ¨¡æ“¬å®Œæˆ"
          fi

      - name: ğŸ“Š Staged deployment
        if: ${{ steps.remediation-decision.outputs.action == 'STAGED_DEPLOY' }}
        run: |
          echo "ğŸ“Š é–‹å§‹åˆ†éšæ®µéƒ¨ç½²..."

          # æª¢æŸ¥ jq æ˜¯å¦å¯ç”¨ï¼ˆåœ¨é–‹å§‹éƒ¨ç½²å‰æª¢æŸ¥ä¸€æ¬¡ï¼‰
          if ! command -v jq &>/dev/null; then
            echo "âŒ éŒ¯èª¤ï¼šjq æœªå®‰è£æˆ–ä¸å¯ç”¨"
            exit 1
          fi

          IFS=',' read -ra PERCENTAGES <<< "${{ env.STAGED_DEPLOY_PERCENTAGES }}"
          for PERCENTAGE in "${PERCENTAGES[@]}"; do
            echo "éƒ¨ç½²åˆ° ${PERCENTAGE}% æµé‡..."
            
            # å¯¦éš›éƒ¨ç½²é‚è¼¯ï¼ˆéœ€æ ¹æ“šå¯¦éš›ç’°å¢ƒèª¿æ•´ï¼‰ï¼š
            # kubectl set env deployment/autonomous-system TRAFFIC_PERCENTAGE=$PERCENTAGE
            # æˆ–ä½¿ç”¨ Istio/Linkerd ç­‰æœå‹™ç¶²æ ¼é€²è¡Œæµé‡åˆ†é…
            echo "[æ¼”ç¤ºæ¨¡å¼] æ¨¡æ“¬éƒ¨ç½²è‡³ ${PERCENTAGE}% æµé‡"

            sleep ${{ env.STAGED_DEPLOY_INTERVAL }}

            # ä½¿ç”¨é‡‘çµ²é›€æœå‹™ URL é€²è¡Œå¥åº·æª¢æŸ¥ï¼ˆåˆ†éšæ®µéƒ¨ç½²é€šå¸¸èˆ‡é‡‘çµ²é›€ä½¿ç”¨ç›¸åŒç«¯é»ï¼‰
            HEALTH=$(curl -s ${{ env.CANARY_SERVICE_URL }}/health 2>/dev/null | jq -r '.status' || echo "unknown")
            if [ "$HEALTH" != "healthy" ]; then
              echo "âŒ éƒ¨ç½²å¤±æ•—ï¼ˆå¥åº·ç‹€æ…‹: $HEALTHï¼‰ï¼Œè‡ªå‹•å›æ»¾..."
              # å˜—è©¦ Kubernetes å›æ»¾ï¼ˆå¦‚æœä½¿ç”¨ kubectlï¼‰
              if command -v kubectl &>/dev/null; then
                if ! kubectl rollout undo deployment/autonomous-system 2>/dev/null; then
                  echo "âš ï¸ Kubernetes å›æ»¾å¤±æ•—æˆ–æœªä½¿ç”¨ Kubernetes"
                fi
              fi
              # å˜—è©¦ docker-compose å›æ»¾ï¼ˆå¦‚æœä½¿ç”¨ docker-composeï¼‰
              if [ -f docker-compose.yml ] && command -v docker-compose &>/dev/null; then
                echo "å˜—è©¦ä½¿ç”¨ docker-compose å›æ»¾..."
                docker-compose down || true
                # å¦‚æœ‰å‰ä¸€ç‰ˆæœ¬æ˜ åƒï¼Œå¯åœ¨æ­¤è™•æŒ‡å®š
              fi
              echo "æ•…éšœæ’é™¤æŒ‡å¼•ï¼š"
              echo "  - Kubernetes: kubectl get pods -l app=autonomous-system"
              echo "  - Docker: docker ps -a"
              exit 1
            fi

            echo "âœ… ${PERCENTAGE}% éƒ¨ç½²æˆåŠŸ"
          done
          
          echo "âœ… åˆ†éšæ®µéƒ¨ç½²å®Œæˆ"

      - name: ğŸš€ Full deployment
        if: ${{ steps.remediation-decision.outputs.action == 'FULL_DEPLOY' }}
        run: |
          echo "ğŸš€ é–‹å§‹å®Œæ•´éƒ¨ç½²..."
          
          # æº–å‚™ docker-compose æª”æ¡ˆï¼ˆå¦‚ä¸å­˜åœ¨ï¼‰
          if [ ! -f docker-compose.yml ]; then
            # ä½¿ç”¨ printf ç”¢ç”Ÿæ­£ç¢ºæ ¼å¼çš„ YAMLï¼ˆé¿å… heredoc ç¸®æ’å•é¡Œï¼‰
            printf '%s\n' \
              "version: '3.8'" \
              "services:" \
              "  app:" \
              "    image: autonomous-system:latest" \
              "    ports:" \
              "      - '8001:8001'" \
              "    environment:" \
              "      - NODE_ENV=production" \
              "    healthcheck:" \
              '      test: ["CMD", "curl", "-f", "http://localhost:8001/health"]' \
              "      interval: 30s" \
              "      timeout: 10s" \
              "      retries: 5" \
              > docker-compose.yml
          fi

          docker-compose build --no-cache
          docker-compose up -d
          
          sleep ${{ env.HEALTH_CHECK_DELAY }}
          curl -f ${{ env.PRIMARY_SERVICE_HEALTH_URL }} || echo "âš ï¸  å¥åº·æª¢æŸ¥å¤±æ•—ï¼ˆæ¼”ç¤ºæ¨¡å¼ï¼‰"
          echo "âœ… å®Œæ•´éƒ¨ç½²å®Œæˆ"

  realtime-monitoring:
    needs: [predictive-failure-detection, auto-remediation]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“Š Collect system metrics
        id: metrics
        run: |

      - name: ğŸš¨ Critical alert on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request?.number;

            const criticalAlert = `## ğŸš¨ CRITICAL ALERT - è‡ªå‹•é§•é§›ç³»çµ±æ•…éšœ

            **æ™‚é–“**ï¼š${new Date().toISOString()}
            **é¢¨éšªç­‰ç´š**ï¼šCRITICAL
            **ç‹€æ…‹**ï¼šè‡ªå‹•å›æ»¾å·²è§¸ç™¼

            ### æ•…éšœè©³æƒ…
            - é æ¸¬é¢¨éšªåˆ†æ•¸ï¼š${{ needs.predictive-failure-detection.outputs.risk_level }}
            - é—œéµæœå‹™æª¢æŸ¥ï¼šå¤±æ•—
            - è‡ªå‹•ä¿®å¾©æ“ä½œï¼šå›æ»¾åˆ°ä¸Šä¸€å€‹ç©©å®šç‰ˆæœ¬

            ### ç«‹å³è¡Œå‹•
            1. âš ï¸ åœæ­¢æ‰€æœ‰æ–°éƒ¨ç½²
            2. ğŸ“ è¯ç¹« DevOps åœ˜éšŠé€²è¡Œäººå·¥å¯©æŸ¥
            3. ğŸ“Š æŸ¥çœ‹å®Œæ•´æ—¥èªŒï¼š${context.payload.pull_request?.html_url}/checks
            4. ğŸ” åˆ†ææ ¹æœ¬åŸå› 

            ### è¯ç¹«æ–¹å¼
            - **ç·Šæ€¥ç†±ç·š**ï¼š+1-XXX-XXX-XXXXï¼ˆå¾…é…ç½®ï¼‰
            - **Slack**ï¼š#critical-alerts
            - **PagerDuty**ï¼šautonomous-system-oncall
            
            > ğŸ’¡ æç¤ºï¼šè«‹åœ¨ repository secrets ä¸­è¨­å®š EMERGENCY_HOTLINEã€SLACK_ALERT_CHANNELã€PAGERDUTY_SERVICE ä»¥è‡ªè¨‚è¯ç¹«æ–¹å¼

            ---
            *æ­¤å‘Šè­¦ç”±è‡ªå‹•é§•é§›ç´š CI ç³»çµ±è‡ªå‹•ç”Ÿæˆ*`;

            if (prNumber) {
              github.rest.issues.createComment({
                issue_number: prNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: criticalAlert,
              });
            }

            console.log("Sending Slack alert...");
            // Integrate Slack webhook here
