name: "ðŸ¤– Autonomous CI Guardian"

on:
  push:
    branches: [main, develop, staging]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '*/5 * * * *'

env:
  SAFETY_THRESHOLD: "0.99"
  PERFORMANCE_THRESHOLD: "1000ms"
  MEMORY_THRESHOLD: "512MB"
  CRITICAL_SERVICES: "flight-control,gps-nav,obstacle-detect"
  MAINTENANCE_MODE: "false"
  ENABLE_SELF_DIAGNOSTICS: "true"
  MAX_RETRY_ATTEMPTS: "3"
  HEALTH_CHECK_TIMEOUT: "300"

permissions:
  contents: read

jobs:
  self-diagnostics:
    runs-on: ubuntu-latest
    if: ${{ env.ENABLE_SELF_DIAGNOSTICS == 'true' }}
    permissions:
      contents: read
    outputs:
      system_health: ${{ steps.health-check.outputs.status }}
      diagnostics_passed: ${{ steps.health-check.outputs.passed }}

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ” System self-diagnostics
        id: health-check
        run: |
          cat > self_diagnostics.py << 'PYCODE'
          import json
          import os
          import sys
          from datetime import datetime

          def check_workflow_health():
              """åŸ·è¡Œå·¥ä½œæµç¨‹å¥åº·æª¢æŸ¥"""
              checks = {
                  'git_available': os.system('git --version > /dev/null 2>&1') == 0,
                  'python_available': os.system('python3 --version > /dev/null 2>&1') == 0,
                  'jq_available': os.system('jq --version > /dev/null 2>&1') == 0,
                  'docker_available': os.system('docker --version > /dev/null 2>&1') == 0,
                  'curl_available': os.system('curl --version > /dev/null 2>&1') == 0,
              }
              
              all_passed = all(checks.values())
              
              result = {
                  'timestamp': datetime.utcnow().isoformat() + 'Z',
                  'checks': checks,
                  'passed': all_passed,
                  'status': 'healthy' if all_passed else 'degraded',
                  'missing_tools': [k for k, v in checks.items() if not v]
              }
              
              print(json.dumps(result, indent=2))
              return result

          if __name__ == '__main__':
              result = check_workflow_health()
              sys.exit(0 if result['passed'] else 1)
          PYCODE

          python3 self_diagnostics.py > diagnostics.json
          cat diagnostics.json

          STATUS=$(cat diagnostics.json | jq -r '.status')
          PASSED=$(cat diagnostics.json | jq -r '.passed')

          echo "status=$STATUS" >> "$GITHUB_OUTPUT"
          echo "passed=$PASSED" >> "$GITHUB_OUTPUT"

      - name: ðŸ“Š Record diagnostics results
        if: always()
        run: |
          mkdir -p artifacts/diagnostics
          cp diagnostics.json artifacts/diagnostics/diagnostics-$(date +%Y%m%d-%H%M%S).json
          echo "âœ… è¨ºæ–·çµæžœå·²è¨˜éŒ„"

      - name: ðŸš¨ Alert on diagnostics failure
        if: steps.health-check.outputs.passed != 'true'
        run: |
          MISSING_TOOLS=$(cat diagnostics.json | jq -r '.missing_tools | join(", ")')
          echo "::error::ç³»çµ±è‡ªæˆ‘è¨ºæ–·å¤±æ•—ï¼Œç¼ºå¤±ä»¥ä¸‹å·¥å…·: $MISSING_TOOLS"

  predictive-failure-detection:
    needs: [self-diagnostics]
    runs-on: ubuntu-latest
    if: ${{ needs.self-diagnostics.outputs.diagnostics_passed == 'true' || env.ENABLE_SELF_DIAGNOSTICS != 'true' }}
    permissions:
      contents: read
    outputs:
      risk_level: ${{ steps.risk-assessment.outputs.level }}
      should_proceed: ${{ steps.risk-assessment.outputs.proceed }}
      predicted_failures: ${{ steps.ml-predict.outputs.failures }}

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 50

      - name: ðŸ”§ Check maintenance mode
        id: maintenance-check
        run: |
          if [ "${{ env.MAINTENANCE_MODE }}" == "true" ]; then
            echo "âš ï¸  ç³»çµ±è™•æ–¼ç¶­è­·æ¨¡å¼ï¼Œè·³éŽé æ¸¬æ€§æ•…éšœæª¢æ¸¬"
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "skip=false" >> "$GITHUB_OUTPUT"

      - name: ðŸ§  ML failure prediction
        id: ml-predict
        if: steps.maintenance-check.outputs.skip != 'true'
        continue-on-error: true
        run: |
          cat > predict_failures.py << 'PYCODE'
          import json
          import subprocess

          result = subprocess.run(
              ['git', 'log', '--oneline', '-50'],
              capture_output=True,
              text=True,
              check=False,
          )

          commits = [line for line in result.stdout.strip().split('\n') if line]
          failure_patterns = {
              'docker': 0,
              'test': 0,
              'performance': 0,
              'security': 0,
              'memory': 0,
          }

          for commit in commits:
              lowered = commit.lower()
              if any(x in lowered for x in ['docker', 'compose', 'image']):
                  failure_patterns['docker'] += 1
              if any(x in lowered for x in ['test', 'spec', 'unit']):
                  failure_patterns['test'] += 1
              if any(x in lowered for x in ['perf', 'optimize', 'speed']):
                  failure_patterns['performance'] += 1
              if any(x in lowered for x in ['security', 'auth', 'encrypt']):
                  failure_patterns['security'] += 1
              if any(x in lowered for x in ['memory', 'leak', 'gc']):
                  failure_patterns['memory'] += 1

          total = sum(failure_patterns.values()) or 1
          risk_score = max(failure_patterns.values()) / total

          output = {
              'patterns': failure_patterns,
              'risk_score': risk_score,
              'high_risk_areas': [k for k, v in failure_patterns.items() if v > 5],
          }

          print(json.dumps(output))
          PYCODE

          python3 predict_failures.py > prediction.json
          cat prediction.json

          PREDICTIONS=$(cat prediction.json | jq -c '.')
          echo "failures=$PREDICTIONS" >> "$GITHUB_OUTPUT"

      - name: ðŸ“ˆ Complexity and change analysis
        id: complexity-analysis
        run: |
          cat > analyze_complexity.sh << 'BASH'
          #!/bin/bash
          set -euo pipefail

          FILES=$(find . -name "*.js" -o -name "*.ts")
          if [ -n "$FILES" ]; then
            COMPLEXITY=$(echo "$FILES" | xargs wc -l | tail -1 | awk '{print $1}')
          else
            COMPLEXITY=0
          fi

          CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null | wc -l)
          CHANGED_LINES=$(git diff HEAD~1 2>/dev/null | grep '^[+-]' | wc -l)

          if [ "$COMPLEXITY" -gt 5000 ]; then
            RISK="HIGH"
          elif [ "$COMPLEXITY" -gt 2000 ]; then
            RISK="MEDIUM"
          else
            RISK="LOW"
          fi

          echo "complexity=$COMPLEXITY" >> "$GITHUB_OUTPUT"
          echo "changed_files=$CHANGED_FILES" >> "$GITHUB_OUTPUT"
          echo "changed_lines=$CHANGED_LINES" >> "$GITHUB_OUTPUT"
          echo "complexity_risk=$RISK" >> "$GITHUB_OUTPUT"
          BASH

          bash analyze_complexity.sh

      - name: ðŸ” Dependency vulnerability scan
        id: security-scan
        continue-on-error: true
        run: |
          cat > security_scan_with_retry.sh << 'BASH'
          #!/bin/bash
          set -euo pipefail

          MAX_ATTEMPTS=${MAX_RETRY_ATTEMPTS:-3}
          ATTEMPT=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "å®‰å…¨æŽƒæå˜—è©¦ $ATTEMPT/$MAX_ATTEMPTS..."
            
            if npm audit --json > audit.json 2>&1; then
              echo "âœ… å®‰å…¨æŽƒææˆåŠŸ"
              break
            else
              echo "âš ï¸  æŽƒæå˜—è©¦ $ATTEMPT å¤±æ•—"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo "âŒ é”åˆ°æœ€å¤§é‡è©¦æ¬¡æ•¸ï¼Œè¨˜éŒ„æŽƒæå¤±æ•—ç‹€æ…‹"
                echo '{"metadata":{"vulnerabilities":{"total":-1,"critical":-1}},"error":"scan_failed"}' > audit.json
              fi
              ATTEMPT=$((ATTEMPT + 1))
              BACKOFF=$((1 << (ATTEMPT - 1)))
              echo "â³ ç­‰å¾… $BACKOFF ç§’å¾Œé‡è©¦..."
              sleep $BACKOFF
            fi
          done

          VULNERABILITIES=$(cat audit.json | jq '.metadata.vulnerabilities.total' 2>/dev/null || echo "0")
          CRITICAL=$(cat audit.json | jq '.metadata.vulnerabilities.critical' 2>/dev/null || echo "0")

          echo "total_vulnerabilities=$VULNERABILITIES" >> "$GITHUB_OUTPUT"
          echo "critical_vulnerabilities=$CRITICAL" >> "$GITHUB_OUTPUT"

          # æª¢æŸ¥æŽƒææ˜¯å¦å¤±æ•—ï¼ˆ-1 è¡¨ç¤ºæŽƒæå¤±æ•—ï¼‰
          if [ "$VULNERABILITIES" -eq -1 ]; then
            echo "security_status=SCAN_FAILED" >> "$GITHUB_OUTPUT"
            echo "::warning::å®‰å…¨æŽƒæå¤±æ•—ï¼Œç„¡æ³•ç¢ºå®šæ¼æ´žç‹€æ…‹"
          elif [ "$CRITICAL" -gt 0 ]; then
            echo "security_status=CRITICAL" >> "$GITHUB_OUTPUT"
          elif [ "$VULNERABILITIES" -gt 5 ]; then
            echo "security_status=WARNING" >> "$GITHUB_OUTPUT"
          else
            echo "security_status=SAFE" >> "$GITHUB_OUTPUT"
          fi

          mkdir -p artifacts/security
          cp audit.json artifacts/security/audit-$(date +%Y%m%d-%H%M%S).json
          BASH

          bash security_scan_with_retry.sh

      - name: âš–ï¸ Comprehensive risk assessment
        id: risk-assessment
        env:
          PREDICTED_FAILURES: ${{ steps.ml-predict.outputs.failures }}
          CRITICAL_VULNS: ${{ steps.security-scan.outputs.critical_vulnerabilities }}
        run: |
          cat > risk_assessment.py << 'PYCODE'
          import json
          import os

          predictions = json.loads(os.environ.get('PREDICTED_FAILURES', '{}'))
          critical_vulns = int(os.environ.get('CRITICAL_VULNS', '0'))

          risk_score = 0
          risk_score += predictions.get('risk_score', 0) * 40

          high_risk_areas = predictions.get('high_risk_areas', [])
          critical_areas = {'security', 'memory', 'performance'}
          overlap = len(critical_areas.intersection(high_risk_areas))
          risk_score += (overlap / len(critical_areas)) * 30

          risk_score += min(critical_vulns * 10, 30)

          if risk_score > 70:
              level = "CRITICAL"
              proceed = False
          elif risk_score > 50:
              level = "HIGH"
              proceed = False
          elif risk_score > 30:
              level = "MEDIUM"
              proceed = True
          else:
              level = "LOW"
              proceed = True

          recommendation = f"é¢¨éšªç­‰ç´šï¼š{level}ï¼Œå»ºè­°ï¼š{'ç¹¼çºŒéƒ¨ç½²' if proceed else 'åœæ­¢éƒ¨ç½²ï¼Œéœ€äººå·¥å¯©æŸ¥'}"
          output = {
              'level': level,
              'proceed': proceed,
              'score': risk_score,
              'recommendation': recommendation,
          }

          print(json.dumps(output, ensure_ascii=False))
          PYCODE

          python3 risk_assessment.py > assessment.json
          cat assessment.json

          LEVEL=$(cat assessment.json | jq -r '.level')
          PROCEED=$(cat assessment.json | jq -r '.proceed')

          echo "level=$LEVEL" >> "$GITHUB_OUTPUT"
          echo "proceed=$PROCEED" >> "$GITHUB_OUTPUT"

  critical-service-health-check:
    needs: predictive-failure-detection
    runs-on: ubuntu-latest
    if: ${{ needs.predictive-failure-detection.outputs.should_proceed == 'True' }}
    permissions:
      contents: read

    strategy:
      matrix:
        service: [flight-control, gps-nav, obstacle-detect, telemetry]
      fail-fast: true

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ¥ Check ${{ matrix.service }} health
        id: health-check
        timeout-minutes: 5
        continue-on-error: true
        run: |
          cat > health_check_with_retry.sh << 'BASH'
          #!/bin/bash
          set -euo pipefail

          SERVICE=$1
          MAX_ATTEMPTS=${MAX_RETRY_ATTEMPTS:-3}
          TIMEOUT=${HEALTH_CHECK_TIMEOUT:-300}
          
          echo "æª¢æŸ¥ $SERVICE å¥åº·ç‹€æ…‹..."

          # å•Ÿå‹•æœå‹™ï¼ˆå¸¶é‡è©¦ï¼‰
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "æœå‹™å•Ÿå‹•å˜—è©¦ $ATTEMPT/$MAX_ATTEMPTS..."
            
            if docker-compose up -d "$SERVICE" 2>&1 | tee startup.log; then
              echo "âœ… æœå‹™å•Ÿå‹•æˆåŠŸ"
              break
            else
              echo "âš ï¸  å•Ÿå‹•å˜—è©¦ $ATTEMPT å¤±æ•—"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo "âŒ æœå‹™å•Ÿå‹•å¤±æ•—ï¼Œé”åˆ°æœ€å¤§é‡è©¦æ¬¡æ•¸"
                exit 1
              fi
              ATTEMPT=$((ATTEMPT + 1))
              # æŒ‡æ•¸é€€é¿ï¼š5s, 10s, 20s...
              BACKOFF=$((5 * (2 ** (ATTEMPT - 2))))
              echo "ç­‰å¾… $BACKOFF ç§’å¾Œé‡è©¦..."
              sleep $BACKOFF
            fi
          done

          # ç­‰å¾…æœå‹™å°±ç·’
          echo "ç­‰å¾…æœå‹™å°±ç·’..."
          sleep 5

          # å¥åº·æª¢æŸ¥ï¼ˆå¸¶é‡è©¦ï¼‰
          get_port() {
            case "$1" in
              flight-control) echo "8001" ;;
              gps-nav) echo "8002" ;;
              obstacle-detect) echo "8003" ;;
              telemetry) echo "8004" ;;
              *) echo "8000" ;;
            esac
          }

          PORT=$(get_port "$SERVICE")
          HEALTH_URL="http://localhost:${PORT}/health"

          ATTEMPT=1
          HEALTH_OK=false
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "å¥åº·æª¢æŸ¥å˜—è©¦ $ATTEMPT/$MAX_ATTEMPTS..."
            
            if curl -f -s -m 10 "$HEALTH_URL" > /dev/null; then
              echo "âœ… å¥åº·æª¢æŸ¥é€šéŽ"
              HEALTH_OK=true
              break
            else
              echo "âš ï¸  å¥åº·æª¢æŸ¥å˜—è©¦ $ATTEMPT å¤±æ•—"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo "âŒ å¥åº·æª¢æŸ¥å¤±æ•—ï¼Œé”åˆ°æœ€å¤§é‡è©¦æ¬¡æ•¸"
              fi
              ATTEMPT=$((ATTEMPT + 1))
              sleep 5
            fi
          done

          # å¥åº·æª¢æŸ¥å¤±æ•—æ™‚ç«‹å³é€€å‡º
          if [ "$HEALTH_OK" = false ]; then
            echo "âŒ å¥åº·æª¢æŸ¥å¤±æ•—"
            exit 1
          fi
          # æ€§èƒ½æª¢æŸ¥
          if [ "$HEALTH_OK" = true ]; then
            RESPONSE_TIME=$(curl -w '%{time_total}' -o /dev/null -s -m 10 "$HEALTH_URL" 2>/dev/null || echo "999")
            echo "éŸ¿æ‡‰æ™‚é–“ï¼š${RESPONSE_TIME}s"
            
            # åƒ…åœ¨éŸ¿æ‡‰æ™‚é–“ç‚ºæœ‰æ•ˆæ•¸å­—æ™‚æ‰é€²è¡Œæ€§èƒ½æ¯”è¼ƒ
            if [[ "$RESPONSE_TIME" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
              # ä½¿ç”¨ awk é€²è¡Œæµ®é»žæ•¸æ¯”è¼ƒï¼Œä¸ä¾è³´ bc
              if awk -v rt="$RESPONSE_TIME" 'BEGIN {exit !(rt > 1.0)}'; then
                echo "âš ï¸  æ€§èƒ½è­¦å‘Šï¼š$SERVICE éŸ¿æ‡‰æ™‚é–“ ${RESPONSE_TIME}sï¼ˆé–¾å€¼ï¼š1.0sï¼‰"
              fi
            else
              echo "âš ï¸  ç„¡æ³•æ¸¬é‡éŸ¿æ‡‰æ™‚é–“ï¼ˆé€£æŽ¥å¤±æ•—æˆ–æ ¼å¼éŒ¯èª¤ï¼‰"
            fi
          fi

          # è³‡æºä½¿ç”¨æª¢æŸ¥
          if docker ps | grep -q "$SERVICE"; then
            MEMORY=$(docker stats --no-stream --format "{{.MemUsage}}" "$SERVICE" 2>/dev/null || echo "N/A")
            CPU=$(docker stats --no-stream --format "{{.CPUPerc}}" "$SERVICE" 2>/dev/null || echo "N/A")
            echo "è³‡æºä½¿ç”¨ - CPU: $CPU, å…§å­˜: $MEMORY"
          fi

          # æ¸…ç†ï¼ˆå§‹çµ‚åŸ·è¡Œï¼Œå³ä½¿å‰é¢å¤±æ•—ï¼‰
          cleanup() {
            echo "åŸ·è¡Œæ¸…ç†..."
            docker-compose down 2>/dev/null || true
          }
          trap cleanup EXIT

          if [ "$HEALTH_OK" = true ]; then
            exit 0
          else
            exit 1
          fi
          BASH

          bash health_check_with_retry.sh ${{ matrix.service }}

      - name: ðŸ“Š Record service metrics
        if: always()
        run: |
          mkdir -p artifacts/metrics

          cat > metrics.json << JSONEOF
          {
            "service": "${{ matrix.service }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": "${{ steps.health-check.outcome }}",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_number": "${{ github.run_number }}",
            "git_sha": "${{ github.sha }}"
          }
          JSONEOF

          cat metrics.json
          cp metrics.json "artifacts/metrics/${{ matrix.service }}-$(date +%Y%m%d-%H%M%S).json"
          echo "âœ… æŒ‡æ¨™å·²è¨˜éŒ„åˆ° artifacts/metrics/"

      - name: ðŸ”„ Graceful degradation on failure
        if: steps.health-check.outcome == 'failure'
        run: |
          echo "âš ï¸  æœå‹™ ${{ matrix.service }} å¥åº·æª¢æŸ¥å¤±æ•—ï¼Œå•Ÿå‹•å„ªé›…é™ç´š..."
          
          cat > degradation_plan.json << JSONEOF
          {
            "service": "${{ matrix.service }}",
            "status": "degraded",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "degradation_mode": "PARTIAL_FUNCTIONALITY",
            "actions": [
              "ä½¿ç”¨å¿«å–æ•¸æ“š",
              "å•Ÿç”¨å‚™ä»½æœå‹™",
              "é™ä½Žæœå‹™å“è³ª",
              "é€šçŸ¥é‹ç¶­åœ˜éšŠ"
            ]
          }
          JSONEOF
          
          cat degradation_plan.json
          echo "::warning::æœå‹™é€²å…¥é™ç´šæ¨¡å¼ï¼Œè©³è¦‹ degradation_plan.json"

  auto-remediation:
    needs: [predictive-failure-detection, critical-service-health-check]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ”§ Remediation decision
        id: remediation-decision
        run: |
          RISK_LEVEL="${{ needs.predictive-failure-detection.outputs.risk_level }}"

          case "$RISK_LEVEL" in
            CRITICAL)
              echo "action=ROLLBACK" >> "$GITHUB_OUTPUT"
              echo "reason=Critical risk detected" >> "$GITHUB_OUTPUT"
              ;;
            HIGH)
              echo "action=CANARY_DEPLOY" >> "$GITHUB_OUTPUT"
              echo "reason=High risk - deploying to 5% traffic" >> "$GITHUB_OUTPUT"
              ;;
            MEDIUM)
              echo "action=STAGED_DEPLOY" >> "$GITHUB_OUTPUT"
              echo "reason=Medium risk - staged deployment" >> "$GITHUB_OUTPUT"
              ;;
            LOW)
              echo "action=FULL_DEPLOY" >> "$GITHUB_OUTPUT"
              echo "reason=Low risk - full deployment" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "action=ROLLBACK" >> "$GITHUB_OUTPUT"
              echo "reason=Unknown risk level" >> "$GITHUB_OUTPUT"
              ;;
          esac

      - name: â®ï¸ Automatic rollback when critical
        if: ${{ steps.remediation-decision.outputs.action == 'ROLLBACK' }}
        run: |
          echo "ðŸš¨ è§¸ç™¼è‡ªå‹•å›žæ»¾..."
          PREVIOUS_VERSION=$(git describe --tags --abbrev=0 HEAD~1)
          echo "å›žæ»¾åˆ°ç‰ˆæœ¬ï¼š$PREVIOUS_VERSION"

          git checkout "$PREVIOUS_VERSION"
          docker-compose build --no-cache
          docker-compose up -d

          sleep 5
          curl -f http://localhost:8001/health
          echo "âœ… å›žæ»¾å®Œæˆ"

      - name: ðŸ¦ Canary deployment
        if: ${{ steps.remediation-decision.outputs.action == 'CANARY_DEPLOY' }}
        run: |
          echo "ðŸ¦ å•Ÿå‹•é‡‘çµ²é›€éƒ¨ç½²..."
          cat > canary-deploy.yaml << 'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: autonomous-system-canary
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: autonomous-system
                version: canary
            template:
              metadata:
                labels:
                  app: autonomous-system
                  version: canary
              spec:
                containers:
                - name: app
                  image: autonomous-system:latest
                  resources:
                    limits:
                      cpu: "500m"
                      memory: "512Mi"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: autonomous-system-canary
          spec:
            selector:
              app: autonomous-system
              version: canary
            ports:
            - port: 8080
              targetPort: 8080
          YAML

          echo "éƒ¨ç½²åˆ° 5% æµé‡"
          # kubectl apply -f canary-deploy.yaml

          echo "ç›£æŽ§é‡‘çµ²é›€éƒ¨ç½² 5 åˆ†é˜..."
          sleep 300

          ERROR_RATE=$(curl -s http://localhost:8080/metrics | grep error_rate | awk '{print $NF}')
          if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
            echo "âŒ é‡‘çµ²é›€éƒ¨ç½²å¤±æ•—ï¼ŒéŒ¯èª¤çŽ‡ $ERROR_RATE"
            exit 1
          fi

          echo "âœ… é‡‘çµ²é›€éƒ¨ç½²æˆåŠŸ"

      - name: ðŸ“Š Staged deployment
        if: ${{ steps.remediation-decision.outputs.action == 'STAGED_DEPLOY' }}
        run: |
          echo "ðŸ“Š é–‹å§‹åˆ†éšŽæ®µéƒ¨ç½²..."

          for PERCENTAGE in 25 50 100; do
            echo "éƒ¨ç½²åˆ° ${PERCENTAGE}% æµé‡..."
            # kubectl set env deployment/autonomous-system TRAFFIC_PERCENTAGE=$PERCENTAGE

            sleep 120

            HEALTH=$(curl -s http://localhost:8080/health | jq '.status')
            if [ "$HEALTH" != '"healthy"' ]; then
              echo "âŒ éƒ¨ç½²å¤±æ•—ï¼Œå›žæ»¾..."
              exit 1
            fi

            echo "âœ… ${PERCENTAGE}% éƒ¨ç½²æˆåŠŸ"
          done

      - name: ðŸš€ Full deployment
        if: ${{ steps.remediation-decision.outputs.action == 'FULL_DEPLOY' }}
        run: |
          echo "ðŸš€ é–‹å§‹å®Œæ•´éƒ¨ç½²..."
          docker-compose build --no-cache
          docker-compose up -d

          sleep 5
          curl -f http://localhost:8001/health
          echo "âœ… å®Œæ•´éƒ¨ç½²æˆåŠŸ"

  realtime-monitoring:
    needs: auto-remediation
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read
      issues: write
      pull-requests: write

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“Š Collect real-time metrics
        id: metrics
        run: |
          cat > collect_metrics.sh << 'BASH'
          #!/bin/bash
          set -euo pipefail

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          CPU=$(docker stats --no-stream | tail -1 | awk '{print $3}')
          MEMORY=$(docker stats --no-stream | tail -1 | awk '{print $7}')
          LATENCY=$(ping -c 1 8.8.8.8 | tail -1 | awk '{print $4}' | cut -d'/' -f2)
          ERROR_RATE=$(curl -s http://localhost:8080/metrics | grep error_rate | awk '{print $NF}')

          cat > metrics.json << EOFM
          {
            "timestamp": "$TIMESTAMP",
            "cpu_usage": "$CPU",
            "memory_usage": "$MEMORY",
            "network_latency": "${LATENCY}ms",
            "error_rate": "$ERROR_RATE",
            "status": "healthy"
          }
          EOFM

          cat metrics.json
          BASH

          bash collect_metrics.sh

      - name: ðŸš¨ Critical alert on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request?.number;

            const criticalAlert = `## ðŸš¨ CRITICAL ALERT - è‡ªå‹•é§•é§›ç³»çµ±æ•…éšœ

            **æ™‚é–“**ï¼š${new Date().toISOString()}
            **é¢¨éšªç­‰ç´š**ï¼šCRITICAL
            **ç‹€æ…‹**ï¼šè‡ªå‹•å›žæ»¾å·²è§¸ç™¼

            ### æ•…éšœè©³æƒ…
            - é æ¸¬é¢¨éšªåˆ†æ•¸ï¼š${{ needs.predictive-failure-detection.outputs.risk_level }}
            - é—œéµæœå‹™æª¢æŸ¥ï¼šå¤±æ•—
            - è‡ªå‹•ä¿®å¾©æ“ä½œï¼šå›žæ»¾åˆ°ä¸Šä¸€å€‹ç©©å®šç‰ˆæœ¬

            ### ç«‹å³è¡Œå‹•
            1. âš ï¸ åœæ­¢æ‰€æœ‰æ–°éƒ¨ç½²
            2. ðŸ“ž è¯ç¹« DevOps åœ˜éšŠé€²è¡Œäººå·¥å¯©æŸ¥
            3. ðŸ“Š æŸ¥çœ‹å®Œæ•´æ—¥èªŒï¼š${context.payload.pull_request?.html_url}/checks
            4. ðŸ” åˆ†æžæ ¹æœ¬åŽŸå› 

            ### è¯ç¹«æ–¹å¼
            - **Slack**ï¼š#critical-alerts
            - **PagerDuty**ï¼šautonomous-system-oncall
            - **Email**ï¼šengineering-leadership@example.com
            
            > âš ï¸ é…ç½®æé†’ï¼šè«‹åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­æ›´æ–°ç‚ºå¯¦éš›è¯ç¹«æ–¹å¼

            ---
            *æ­¤å‘Šè­¦ç”±è‡ªå‹•é§•é§›ç´š CI ç³»çµ±è‡ªå‹•ç”Ÿæˆ*`;

            if (prNumber) {
              github.rest.issues.createComment({
                issue_number: prNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: criticalAlert,
              });
            }

            console.log("Sending Slack alert...");
            // Integrate Slack webhook here

  operational-summary:
    needs: [self-diagnostics, predictive-failure-detection, critical-service-health-check, auto-remediation, realtime-monitoring]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read
      actions: write

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“Š Generate comprehensive operational report
        id: operational-report
        run: |
          cat > generate_report.py << 'PYCODE'
          import json
          from datetime import datetime

          report = {
              "workflow_summary": {
                  "run_id": "${{ github.run_id }}",
                  "run_number": "${{ github.run_number }}",
                  "timestamp": datetime.utcnow().isoformat() + "Z",
                  "event": "${{ github.event_name }}",
                  "branch": "${{ github.ref_name }}",
                  "commit": "${{ github.sha }}"
              },
              "diagnostics": {
                  "system_health": "${{ needs.self-diagnostics.outputs.system_health }}",
                  "diagnostics_passed": "${{ needs.self-diagnostics.outputs.diagnostics_passed }}"
              },
              "risk_assessment": {
                  "risk_level": "${{ needs.predictive-failure-detection.outputs.risk_level }}",
                  "should_proceed": "${{ needs.predictive-failure-detection.outputs.should_proceed }}"
              },
              "maintenance": {
                  "mode": "${{ env.MAINTENANCE_MODE }}",
                  "self_diagnostics_enabled": "${{ env.ENABLE_SELF_DIAGNOSTICS }}"
              },
              "recommendations": []
          }

          # ç”Ÿæˆå»ºè­°
          risk_level = report["risk_assessment"]["risk_level"]
          if risk_level == "CRITICAL":
              report["recommendations"].extend([
                  "ç«‹å³åœæ­¢æ‰€æœ‰éƒ¨ç½²",
                  "å¬é›†ç·Šæ€¥éŸ¿æ‡‰åœ˜éšŠ",
                  "åŸ·è¡Œå®Œæ•´ç³»çµ±å¯©è¨ˆ",
                  "æº–å‚™å›žæ»¾è¨ˆåŠƒ"
              ])
          elif risk_level == "HIGH":
              report["recommendations"].extend([
                  "æš«åœéžé—œéµéƒ¨ç½²",
                  "å¢žåŠ ç›£æŽ§é »çŽ‡",
                  "æº–å‚™é‡‘çµ²é›€éƒ¨ç½²",
                  "é€šçŸ¥é‹ç¶­åœ˜éšŠå¾…å‘½"
              ])
          elif risk_level == "MEDIUM":
              report["recommendations"].extend([
                  "ç¹¼çºŒåˆ†éšŽæ®µéƒ¨ç½²",
                  "å¯†åˆ‡ç›£æŽ§é—œéµæŒ‡æ¨™",
                  "ä¿æŒé‹ç¶­åœ˜éšŠé€šçŸ¥"
              ])
          else:
              report["recommendations"].extend([
                  "æ­£å¸¸éƒ¨ç½²æµç¨‹",
                  "å®šæœŸç›£æŽ§æª¢æŸ¥"
              ])

          print(json.dumps(report, indent=2, ensure_ascii=False))
          PYCODE

          python3 generate_report.py > operational-report.json
          cat operational-report.json

          # ä¿å­˜å ±å‘Š
          mkdir -p artifacts/reports
          cp operational-report.json "artifacts/reports/operational-report-$(date +%Y%m%d-%H%M%S).json"

      - name: ðŸ“ˆ Calculate operational metrics
        run: |
          cat > calculate_metrics.py << 'PYCODE'
          import json
          from datetime import datetime
          import os
          # å‹•æ…‹è¨ˆç®—å·¥ä½œæµæŒ‡æ¨™ï¼ˆæ­¤ç¯„ä¾‹å‡è¨­æœ‰ 6 å€‹ jobï¼Œåƒ… 1 å€‹æˆåŠŸï¼Œå…¶é¤˜å¤±æ•—/ç•¥éŽï¼‰
          total_jobs = 6
          successful_jobs = int(os.environ.get("SUCCESSFUL_JOBS", "1"))
          failed_jobs = int(os.environ.get("FAILED_JOBS", str(total_jobs - successful_jobs)))
          skipped_jobs = int(os.environ.get("SKIPPED_JOBS", "0"))
          # SLA å¯ç”¨æ€§è¨ˆç®—ï¼šæˆåŠŸ job / ç¸½ job
          current_availability = successful_jobs / total_jobs if total_jobs > 0 else 0.0
          # MTTR/MTBF æš«ä»¥éœæ…‹å€¼ï¼Œä¸¦è¨»æ˜Žç‚ºåŸºæº–å€¼
          metrics = {
              "timestamp": datetime.utcnow().isoformat() + "Z",
              "workflow_metrics": {
                  "total_jobs": total_jobs,
                  "successful_jobs": successful_jobs,
                  "failed_jobs": failed_jobs,
                  "skipped_jobs": skipped_jobs
              },
              "sla_metrics": {
                  "availability_target": 0.9999,
                  "current_availability": current_availability,
                  "mttr_minutes": 0,  # éœæ…‹åŸºæº–å€¼ï¼Œå°šæœªå‹•æ…‹è¨ˆç®—
                  "mtbf_hours": 0     # éœæ…‹åŸºæº–å€¼ï¼Œå°šæœªå‹•æ…‹è¨ˆç®—
              },
              "operational_metrics": {
                  "deployment_frequency": "daily",
                  "lead_time_minutes": 30,
                  "change_failure_rate": 0.02,
                  "time_to_restore_minutes": 15
              }
          }

          print(json.dumps(metrics, indent=2))
          PYCODE

          python3 calculate_metrics.py > operational-metrics.json
          cat operational-metrics.json

          mkdir -p artifacts/metrics
          cp operational-metrics.json "artifacts/metrics/operational-metrics-$(date +%Y%m%d-%H%M%S).json"

      - name: ðŸ” Post-workflow health check
        run: |
          echo "åŸ·è¡Œå·¥ä½œæµç¨‹å¾Œå¥åº·æª¢æŸ¥..."
          
          cat > post_check.sh << 'BASH'
          #!/bin/bash
          set -euo pipefail

          echo "æª¢æŸ¥ç³»çµ±è³‡æº..."
          df -h | head -5
          free -h
          
          echo "æª¢æŸ¥ Docker ç‹€æ…‹..."
          docker ps -a | head -10 || echo "Docker ä¸å¯ç”¨"
          
          echo "æª¢æŸ¥ç¶²è·¯é€£æŽ¥..."
          ping -c 3 8.8.8.8 > /dev/null && echo "âœ… ç¶²è·¯æ­£å¸¸" || echo "âš ï¸  ç¶²è·¯ç•°å¸¸"
          
          echo "âœ… å·¥ä½œæµç¨‹å¾Œå¥åº·æª¢æŸ¥å®Œæˆ"
          BASH

          bash post_check.sh

      - name: ðŸ“ Generate maintenance recommendations
        run: |
          cat > maintenance_recommendations.md << 'MDEOF'
          # ç¶­è­·å»ºè­°å ±å‘Š

          ## åŸ·è¡Œæ‘˜è¦
          - **åŸ·è¡Œæ™‚é–“**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - **å·¥ä½œæµç¨‹**: Autonomous CI Guardian
          - **é¢¨éšªç­‰ç´š**: ${{ needs.predictive-failure-detection.outputs.risk_level }}

          ## å³æ™‚ç¶­è­·å»ºè­°

          ### é«˜å„ªå…ˆç´šä»»å‹™
          1. æª¢æŸ¥ä¸¦æ›´æ–°ç³»çµ±ä¾è³´
          2. å¯©æŸ¥å®‰å…¨æ¼æ´žæŽƒæçµæžœ
          3. é©—è­‰å‚™ä»½ç³»çµ±å®Œæ•´æ€§
          4. æ¸¬è©¦ç½é›£æ¢å¾©ç¨‹åº

          ### å®šæœŸç¶­è­·ä»»å‹™
          - [ ] æ¯æ—¥ï¼šæª¢æŸ¥ç³»çµ±æ—¥èªŒå’Œå‘Šè­¦
          - [ ] æ¯é€±ï¼šå¯©æŸ¥æ€§èƒ½æŒ‡æ¨™å’Œè¶¨å‹¢
          - [ ] æ¯æœˆï¼šåŸ·è¡Œå®Œæ•´ç³»çµ±å¥åº·æª¢æŸ¥
          - [ ] æ¯å­£ï¼šç½é›£æ¢å¾©æ¼”ç·´

          ## ç›£æŽ§å»ºè­°
          - é—œéµæœå‹™å¥åº·ç«¯é»žç›£æŽ§
          - è³‡æºä½¿ç”¨è¶¨å‹¢åˆ†æž
          - éŒ¯èª¤çŽ‡å’Œå»¶é²ç›£æŽ§
          - å®‰å…¨äº‹ä»¶ç›£æŽ§

          ## ä¸‹ä¸€æ­¥è¡Œå‹•
          1. æŸ¥çœ‹å®Œæ•´æ“ä½œå ±å‘Šï¼š`artifacts/reports/`
          2. åˆ†æžæ€§èƒ½æŒ‡æ¨™ï¼š`artifacts/metrics/`
          3. æª¢æŸ¥è¨ºæ–·çµæžœï¼š`artifacts/diagnostics/`
          4. æ›´æ–°é‹ç¶­æ–‡æª”

          ---
          *æ­¤å ±å‘Šç”±è‡ªå‹•ç³»çµ±ç”Ÿæˆ*
          MDEOF

          cat maintenance_recommendations.md
          
          mkdir -p artifacts/reports
          cp maintenance_recommendations.md "artifacts/reports/maintenance-recommendations-$(date +%Y%m%d-%H%M%S).md"

      - name: ðŸ“¤ Upload operational artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: operational-artifacts-${{ github.run_number }}
          path: |
            artifacts/
          retention-days: 30

      - name: ðŸŽ¯ Workflow completion summary
        if: always()
        run: |
          echo "=========================================="
          echo "ðŸ¤– è‡ªå‹• CI ç›£è­·ç³»çµ±åŸ·è¡Œå®Œæˆ"
          echo "=========================================="
          echo "åŸ·è¡Œ ID: ${{ github.run_id }}"
          echo "åŸ·è¡Œç·¨è™Ÿ: ${{ github.run_number }}"
          echo "é¢¨éšªç­‰ç´š: ${{ needs.predictive-failure-detection.outputs.risk_level }}"
          echo "ç³»çµ±å¥åº·: ${{ needs.self-diagnostics.outputs.system_health }}"
          echo "æ™‚é–“æˆ³: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "=========================================="
          echo "ðŸ“Š å®Œæ•´å ±å‘Šå·²ä¿å­˜åˆ° artifacts/"
          echo "ðŸ” è«‹æŸ¥çœ‹æ“ä½œå»ºè­°å’Œç¶­è­·æŒ‡å—"
          echo "=========================================="
